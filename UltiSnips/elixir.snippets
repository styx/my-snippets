# Elixir

# Helper functions

global !p
import vim
import os.path

def val_or_nil(tx):
  return ('nil' if tx == '_' else tx)

def elixir_mix_module_name():
	current_file_path_without_ext = vim.eval('expand("%:p:r")') or ""
	m = re.search(r'/lib(.+)$', current_file_path_without_ext)
	name_parts = m.group().split('/lib/')[-1].split('/')
	return '.'.join(map(lambda x:x.capitalize(), name_parts))

endglobal

# Snipets

snippet mod
__MODULE__
endsnippet

#snippet mod
#`!p snip.rv = elixir_mix_module_name()`
#endsnippet

snippet defin "def function(n), do: n"
def ${1:name}, do: ${2}
endsnippet

snippet defpin
defp ${1:name}, do: ${2}
endsnippet

snippet defst
defmodule `!p snip.rv = module_nane = elixir_mix_module_name()` do
  ${1:@derive [Access]}

  defstruct ${2:fields}
  @type t :: %__MODULE__{$0$2}

  def new, do: %`!p snip.rv = module_nane`{}
end
endsnippet

snippet defsup
defmodule `!p snip.rv = elixir_mix_module_name()` do
  use Supervisor

  def start_link do
    Supervisor.start_link(__MODULE__, nil)
  end

  def init(${1:_}) do
    processes = [worker(${2:worker_module_name}, [${3:params}])$0]
    supervise(processes, strategy: ${5::one_for_one})
  end
end
endsnippet

snippet defgs
defmodule `!p snip.rv = elixir_mix_module_name()` do

  use GenServer

  @doc """
  ${1:module_doc}
  """

  def start(${2:_}) do
    GenServer.start_link(__MODULE__, `!p snip.rv = the_val = val_or_nil(t[2])`)
  end

  def init($2) do
    {:ok, `!p snip.rv = the_val`}
  end
$0
  def handle_cast({:}, state) do
    {:noreply, state}
  end

  def handle_call({:}, _caller, state) do
    {:reply, result, state}
  end

end
endsnippet

